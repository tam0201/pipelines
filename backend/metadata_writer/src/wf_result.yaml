- container:
    args:
    - --a
    - '{{inputs.parameters.a}}'
    - --b
    - '4'
    - '----output-paths'
    - /tmp/outputs/Output/data
    command:
    - sh
    - -ec
    - 'program_path=$(mktemp)

      printf "%s" "$0" > "$program_path"

      python3 -u "$program_path" "$@"

      '
    - "def add(a, b):\n    '''Calculates sum of two arguments'''\n    return a + b\n\
      \ndef _serialize_float(float_value: float) -> str:\n    if isinstance(float_value,\
      \ str):\n        return float_value\n    if not isinstance(float_value, (float,\
      \ int)):\n        raise TypeError('Value \"{}\" has type \"{}\" instead of float.'.format(\n\
      \            str(float_value), str(type(float_value))))\n    return str(float_value)\n\
      \nimport argparse\n_parser = argparse.ArgumentParser(prog='Add', description='Calculates\
      \ sum of two arguments')\n_parser.add_argument(\"--a\", dest=\"a\", type=float,\
      \ required=True, default=argparse.SUPPRESS)\n_parser.add_argument(\"--b\", dest=\"\
      b\", type=float, required=True, default=argparse.SUPPRESS)\n_parser.add_argument(\"\
      ----output-paths\", dest=\"_output_paths\", type=str, nargs=1)\n_parsed_args\
      \ = vars(_parser.parse_args())\n_output_files = _parsed_args.pop(\"_output_paths\"\
      , [])\n\n_outputs = add(**_parsed_args)\n\n_outputs = [_outputs]\n\n_output_serializers\
      \ = [\n    _serialize_float,\n\n]\n\nimport os\nfor idx, output_file in enumerate(_output_files):\n\
      \    try:\n        os.makedirs(os.path.dirname(output_file))\n    except OSError:\n\
      \        pass\n    with open(output_file, 'w') as f:\n        f.write(_output_serializers[idx](_outputs[idx]))\n"
    image: python:3.7
    name: ''
    resources: {}
    volumeMounts:
    - mountPath: /tmp/outputs/Output
      name: data-storage
      subPath: artifact_data/{{workflow.uid}}_{{pod.name}}/add-Output
  inputs:
    parameters:
    - name: a
  metadata:
    annotations:
      pipelines.kubeflow.org/arguments.parameters: '{"a": "{{inputs.parameters.a}}",
        "b": "4"}'
      pipelines.kubeflow.org/component_ref: '{}'
      pipelines.kubeflow.org/component_spec: '{"description": "Calculates sum of two
        arguments", "implementation": {"container": {"args": ["--a", {"inputValue":
        "a"}, "--b", {"inputValue": "b"}, "----output-paths", {"outputPath": "Output"}],
        "command": ["sh", "-ec", "program_path=$(mktemp)\nprintf \"%s\" \"$0\" > \"$program_path\"\npython3
        -u \"$program_path\" \"$@\"\n", "def add(a, b):\n   ''''''Calculates sum of
        two arguments''''''\n   return a + b\n\ndef _serialize_float(float_value:
        float) -> str:\n    if isinstance(float_value, str):\n        return float_value\n    if
        not isinstance(float_value, (float, int)):\n        raise TypeError(''Value
        \"{}\" has type \"{}\" instead of float.''.format(\n            str(float_value),
        str(type(float_value))))\n    return str(float_value)\n\nimport argparse\n_parser
        = argparse.ArgumentParser(prog=''Add'', description=''Calculates sum of two
        arguments'')\n_parser.add_argument(\"--a\", dest=\"a\", type=float, required=True,
        default=argparse.SUPPRESS)\n_parser.add_argument(\"--b\", dest=\"b\", type=float,
        required=True, default=argparse.SUPPRESS)\n_parser.add_argument(\"----output-paths\",
        dest=\"_output_paths\", type=str, nargs=1)\n_parsed_args = vars(_parser.parse_args())\n_output_files
        = _parsed_args.pop(\"_output_paths\", [])\n\n_outputs = add(**_parsed_args)\n\n_outputs
        = [_outputs]\n\n_output_serializers = [\n    _serialize_float,\n\n]\n\nimport
        os\nfor idx, output_file in enumerate(_output_files):\n    try:\n        os.makedirs(os.path.dirname(output_file))\n    except
        OSError:\n        pass\n    with open(output_file, ''w'') as f:\n        f.write(_output_serializers[idx](_outputs[idx]))\n"],
        "image": "python:3.7"}}, "inputs": [{"name": "a", "type": "Float"}, {"name":
        "b", "type": "Float"}], "name": "Add", "outputs": [{"name": "Output", "type":
        "Float"}]}'
      sidecar.istio.io/inject: 'false'
    labels:
      pipelines.kubeflow.org/cache_enabled: 'true'
      pipelines.kubeflow.org/enable_caching: 'true'
      pipelines.kubeflow.org/kfp_sdk_version: 1.8.13
      pipelines.kubeflow.org/pipeline-sdk-type: kfp
  name: add
  outputs:
    parameters:
    - name: add-Output
      valueFrom:
        path: /tmp/outputs/Output/data
    - name: add-Output-subpath
      value: artifact_data/{{workflow.uid}}_{{pod.name}}/add-Output
- container:
    args:
    - --a
    - '{{inputs.parameters.my-divmod-quotient}}'
    - --b
    - '{{inputs.parameters.c}}'
    - '----output-paths'
    - /tmp/outputs/Output/data
    command:
    - sh
    - -ec
    - 'program_path=$(mktemp)

      printf "%s" "$0" > "$program_path"

      python3 -u "$program_path" "$@"

      '
    - "def add(a, b):\n    '''Calculates sum of two arguments'''\n    return a + b\n\
      \ndef _serialize_float(float_value: float) -> str:\n    if isinstance(float_value,\
      \ str):\n        return float_value\n    if not isinstance(float_value, (float,\
      \ int)):\n        raise TypeError('Value \"{}\" has type \"{}\" instead of float.'.format(\n\
      \            str(float_value), str(type(float_value))))\n    return str(float_value)\n\
      \nimport argparse\n_parser = argparse.ArgumentParser(prog='Add', description='Calculates\
      \ sum of two arguments')\n_parser.add_argument(\"--a\", dest=\"a\", type=float,\
      \ required=True, default=argparse.SUPPRESS)\n_parser.add_argument(\"--b\", dest=\"\
      b\", type=float, required=True, default=argparse.SUPPRESS)\n_parser.add_argument(\"\
      ----output-paths\", dest=\"_output_paths\", type=str, nargs=1)\n_parsed_args\
      \ = vars(_parser.parse_args())\n_output_files = _parsed_args.pop(\"_output_paths\"\
      , [])\n\n_outputs = add(**_parsed_args)\n\n_outputs = [_outputs]\n\n_output_serializers\
      \ = [\n    _serialize_float,\n\n]\n\nimport os\nfor idx, output_file in enumerate(_output_files):\n\
      \    try:\n        os.makedirs(os.path.dirname(output_file))\n    except OSError:\n\
      \        pass\n    with open(output_file, 'w') as f:\n        f.write(_output_serializers[idx](_outputs[idx]))\n"
    image: python:3.7
    name: ''
    resources: {}
    volumeMounts:
    - mountPath: /tmp/outputs/Output
      name: data-storage
      subPath: artifact_data/{{workflow.uid}}_{{pod.name}}/add-2-Output
  inputs:
    parameters:
    - name: c
    - name: my-divmod-quotient
  metadata:
    annotations:
      pipelines.kubeflow.org/arguments.parameters: '{"a": "{{inputs.parameters.my-divmod-quotient}}",
        "b": "{{inputs.parameters.c}}"}'
      pipelines.kubeflow.org/component_ref: '{}'
      pipelines.kubeflow.org/component_spec: '{"description": "Calculates sum of two
        arguments", "implementation": {"container": {"args": ["--a", {"inputValue":
        "a"}, "--b", {"inputValue": "b"}, "----output-paths", {"outputPath": "Output"}],
        "command": ["sh", "-ec", "program_path=$(mktemp)\nprintf \"%s\" \"$0\" > \"$program_path\"\npython3
        -u \"$program_path\" \"$@\"\n", "def add(a, b):\n   ''''''Calculates sum of
        two arguments''''''\n   return a + b\n\ndef _serialize_float(float_value:
        float) -> str:\n    if isinstance(float_value, str):\n        return float_value\n    if
        not isinstance(float_value, (float, int)):\n        raise TypeError(''Value
        \"{}\" has type \"{}\" instead of float.''.format(\n            str(float_value),
        str(type(float_value))))\n    return str(float_value)\n\nimport argparse\n_parser
        = argparse.ArgumentParser(prog=''Add'', description=''Calculates sum of two
        arguments'')\n_parser.add_argument(\"--a\", dest=\"a\", type=float, required=True,
        default=argparse.SUPPRESS)\n_parser.add_argument(\"--b\", dest=\"b\", type=float,
        required=True, default=argparse.SUPPRESS)\n_parser.add_argument(\"----output-paths\",
        dest=\"_output_paths\", type=str, nargs=1)\n_parsed_args = vars(_parser.parse_args())\n_output_files
        = _parsed_args.pop(\"_output_paths\", [])\n\n_outputs = add(**_parsed_args)\n\n_outputs
        = [_outputs]\n\n_output_serializers = [\n    _serialize_float,\n\n]\n\nimport
        os\nfor idx, output_file in enumerate(_output_files):\n    try:\n        os.makedirs(os.path.dirname(output_file))\n    except
        OSError:\n        pass\n    with open(output_file, ''w'') as f:\n        f.write(_output_serializers[idx](_outputs[idx]))\n"],
        "image": "python:3.7"}}, "inputs": [{"name": "a", "type": "Float"}, {"name":
        "b", "type": "Float"}], "name": "Add", "outputs": [{"name": "Output", "type":
        "Float"}]}'
      sidecar.istio.io/inject: 'false'
    labels:
      pipelines.kubeflow.org/cache_enabled: 'true'
      pipelines.kubeflow.org/enable_caching: 'true'
      pipelines.kubeflow.org/kfp_sdk_version: 1.8.13
      pipelines.kubeflow.org/pipeline-sdk-type: kfp
  name: add-2
  outputs: {}
- dag:
    tasks:
    - arguments:
        parameters:
        - name: a
          value: '{{inputs.parameters.a}}'
      name: add
      template: add
    - arguments:
        parameters:
        - name: c
          value: '{{inputs.parameters.c}}'
        - name: my-divmod-quotient
          value: '{{tasks.my-divmod.outputs.parameters.my-divmod-quotient}}'
      dependencies:
      - my-divmod
      name: add-2
      template: add-2
    - arguments:
        parameters:
        - name: add-Output
          value: '{{tasks.add.outputs.parameters.add-Output}}'
        - name: b
          value: '{{inputs.parameters.b}}'
      dependencies:
      - add
      name: my-divmod
      template: my-divmod
  inputs:
    parameters:
    - name: a
    - name: b
    - name: c
  metadata:
    annotations:
      sidecar.istio.io/inject: 'false'
    labels:
      pipelines.kubeflow.org/cache_enabled: 'true'
  name: calculation-pipeline
  outputs: {}
- container:
    args:
    - --dividend
    - '{{inputs.parameters.add-Output}}'
    - --divisor
    - '{{inputs.parameters.b}}'
    - '----output-paths'
    - /tmp/outputs/quotient/data
    - /tmp/outputs/remainder/data
    - /tmp/outputs/mlpipeline_ui_metadata/data
    - /tmp/outputs/mlpipeline_metrics/data
    command:
    - sh
    - -ec
    - 'program_path=$(mktemp)

      printf "%s" "$0" > "$program_path"

      python3 -u "$program_path" "$@"

      '
    - "def my_divmod(dividend, divisor):\n    '''Divides two numbers and calculate\
      \  the quotient and remainder'''\n\n    #Imports inside a component function:\n\
      \    import numpy as np\n\n    #This function demonstrates how to use nested\
      \ functions inside a component function:\n    def divmod_helper(dividend, divisor):\n\
      \        return np.divmod(dividend, divisor)\n\n    (quotient, remainder) =\
      \ divmod_helper(dividend, divisor)\n\n    from tensorflow.python.lib.io import\
      \ file_io\n    import json\n\n    # Exports a sample tensorboard:\n    metadata\
      \ = {\n      'outputs' : [{\n        'type': 'tensorboard',\n        'source':\
      \ 'gs://ml-pipeline-dataset/tensorboard-train',\n      }]\n    }\n\n    # Exports\
      \ two sample metrics:\n    metrics = {\n      'metrics': [{\n          'name':\
      \ 'quotient',\n          'numberValue':  float(quotient),\n        },{\n   \
      \       'name': 'remainder',\n          'numberValue':  float(remainder),\n\
      \        }]}\n\n    from collections import namedtuple\n    divmod_output =\
      \ namedtuple('MyDivmodOutput', ['quotient', 'remainder', 'mlpipeline_ui_metadata',\
      \ 'mlpipeline_metrics'])\n    return divmod_output(quotient, remainder, json.dumps(metadata),\
      \ json.dumps(metrics))\n\ndef _serialize_float(float_value: float) -> str:\n\
      \    if isinstance(float_value, str):\n        return float_value\n    if not\
      \ isinstance(float_value, (float, int)):\n        raise TypeError('Value \"\
      {}\" has type \"{}\" instead of float.'.format(\n            str(float_value),\
      \ str(type(float_value))))\n    return str(float_value)\n\nimport argparse\n\
      _parser = argparse.ArgumentParser(prog='My divmod', description='Divides two\
      \ numbers and calculate  the quotient and remainder')\n_parser.add_argument(\"\
      --dividend\", dest=\"dividend\", type=float, required=True, default=argparse.SUPPRESS)\n\
      _parser.add_argument(\"--divisor\", dest=\"divisor\", type=float, required=True,\
      \ default=argparse.SUPPRESS)\n_parser.add_argument(\"----output-paths\", dest=\"\
      _output_paths\", type=str, nargs=4)\n_parsed_args = vars(_parser.parse_args())\n\
      _output_files = _parsed_args.pop(\"_output_paths\", [])\n\n_outputs = my_divmod(**_parsed_args)\n\
      \n_output_serializers = [\n    _serialize_float,\n    _serialize_float,\n  \
      \  str,\n    str,\n\n]\n\nimport os\nfor idx, output_file in enumerate(_output_files):\n\
      \    try:\n        os.makedirs(os.path.dirname(output_file))\n    except OSError:\n\
      \        pass\n    with open(output_file, 'w') as f:\n        f.write(_output_serializers[idx](_outputs[idx]))\n"
    image: tensorflow/tensorflow:1.11.0-py3
    name: ''
    resources: {}
    volumeMounts:
    - mountPath: /tmp/outputs/mlpipeline_ui_metadata
      name: data-storage
      subPath: artifact_data/{{workflow.uid}}_{{pod.name}}/mlpipeline-ui-metadata
    - mountPath: /tmp/outputs/mlpipeline_metrics
      name: data-storage
      subPath: artifact_data/{{workflow.uid}}_{{pod.name}}/mlpipeline-metrics
    - mountPath: /tmp/outputs/quotient
      name: data-storage
      subPath: artifact_data/{{workflow.uid}}_{{pod.name}}/my-divmod-quotient
    - mountPath: /tmp/outputs/remainder
      name: data-storage
      subPath: artifact_data/{{workflow.uid}}_{{pod.name}}/my-divmod-remainder
  inputs:
    parameters:
    - name: add-Output
    - name: b
  metadata:
    annotations:
      pipelines.kubeflow.org/arguments.parameters: '{"dividend": "{{inputs.parameters.add-Output}}",
        "divisor": "{{inputs.parameters.b}}"}'
      pipelines.kubeflow.org/component_ref: '{}'
      pipelines.kubeflow.org/component_spec: '{"description": "Divides two numbers
        and calculate  the quotient and remainder", "implementation": {"container":
        {"args": ["--dividend", {"inputValue": "dividend"}, "--divisor", {"inputValue":
        "divisor"}, "----output-paths", {"outputPath": "quotient"}, {"outputPath":
        "remainder"}, {"outputPath": "mlpipeline_ui_metadata"}, {"outputPath": "mlpipeline_metrics"}],
        "command": ["sh", "-ec", "program_path=$(mktemp)\nprintf \"%s\" \"$0\" > \"$program_path\"\npython3
        -u \"$program_path\" \"$@\"\n", "def my_divmod(dividend, divisor):\n    ''''''Divides
        two numbers and calculate  the quotient and remainder''''''\n\n    #Imports
        inside a component function:\n    import numpy as np\n\n    #This function
        demonstrates how to use nested functions inside a component function:\n    def
        divmod_helper(dividend, divisor):\n        return np.divmod(dividend, divisor)\n\n    (quotient,
        remainder) = divmod_helper(dividend, divisor)\n\n    from tensorflow.python.lib.io
        import file_io\n    import json\n\n    # Exports a sample tensorboard:\n    metadata
        = {\n      ''outputs'' : [{\n        ''type'': ''tensorboard'',\n        ''source'':
        ''gs://ml-pipeline-dataset/tensorboard-train'',\n      }]\n    }\n\n    #
        Exports two sample metrics:\n    metrics = {\n      ''metrics'': [{\n          ''name'':
        ''quotient'',\n          ''numberValue'':  float(quotient),\n        },{\n          ''name'':
        ''remainder'',\n          ''numberValue'':  float(remainder),\n        }]}\n\n    from
        collections import namedtuple\n    divmod_output = namedtuple(''MyDivmodOutput'',
        [''quotient'', ''remainder'', ''mlpipeline_ui_metadata'', ''mlpipeline_metrics''])\n    return
        divmod_output(quotient, remainder, json.dumps(metadata), json.dumps(metrics))\n\ndef
        _serialize_float(float_value: float) -> str:\n    if isinstance(float_value,
        str):\n        return float_value\n    if not isinstance(float_value, (float,
        int)):\n        raise TypeError(''Value \"{}\" has type \"{}\" instead of
        float.''.format(\n            str(float_value), str(type(float_value))))\n    return
        str(float_value)\n\nimport argparse\n_parser = argparse.ArgumentParser(prog=''My
        divmod'', description=''Divides two numbers and calculate  the quotient and
        remainder'')\n_parser.add_argument(\"--dividend\", dest=\"dividend\", type=float,
        required=True, default=argparse.SUPPRESS)\n_parser.add_argument(\"--divisor\",
        dest=\"divisor\", type=float, required=True, default=argparse.SUPPRESS)\n_parser.add_argument(\"----output-paths\",
        dest=\"_output_paths\", type=str, nargs=4)\n_parsed_args = vars(_parser.parse_args())\n_output_files
        = _parsed_args.pop(\"_output_paths\", [])\n\n_outputs = my_divmod(**_parsed_args)\n\n_output_serializers
        = [\n    _serialize_float,\n    _serialize_float,\n    str,\n    str,\n\n]\n\nimport
        os\nfor idx, output_file in enumerate(_output_files):\n    try:\n        os.makedirs(os.path.dirname(output_file))\n    except
        OSError:\n        pass\n    with open(output_file, ''w'') as f:\n        f.write(_output_serializers[idx](_outputs[idx]))\n"],
        "image": "tensorflow/tensorflow:1.11.0-py3"}}, "inputs": [{"name": "dividend",
        "type": "Float"}, {"name": "divisor", "type": "Float"}], "name": "My divmod",
        "outputs": [{"name": "quotient", "type": "Float"}, {"name": "remainder", "type":
        "Float"}, {"name": "mlpipeline_ui_metadata", "type": "UI_metadata"}, {"name":
        "mlpipeline_metrics", "type": "Metrics"}]}'
      sidecar.istio.io/inject: 'false'
    labels:
      pipelines.kubeflow.org/cache_enabled: 'true'
      pipelines.kubeflow.org/enable_caching: 'true'
      pipelines.kubeflow.org/kfp_sdk_version: 1.8.13
      pipelines.kubeflow.org/pipeline-sdk-type: kfp
  name: my-divmod
  outputs:
    parameters:
    - name: my-divmod-quotient
      valueFrom:
        path: /tmp/outputs/quotient/data
    - name: mlpipeline-ui-metadata-subpath
      value: artifact_data/{{workflow.uid}}_{{pod.name}}/mlpipeline-ui-metadata
    - name: mlpipeline-metrics-subpath
      value: artifact_data/{{workflow.uid}}_{{pod.name}}/mlpipeline-metrics
    - name: my-divmod-quotient-subpath
      value: artifact_data/{{workflow.uid}}_{{pod.name}}/my-divmod-quotient
    - name: my-divmod-remainder-subpath
      value: artifact_data/{{workflow.uid}}_{{pod.name}}/my-divmod-remainder
